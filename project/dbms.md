# 简易数据库管理系统

## 是什么
基于有限内存空间（缓冲区大小为520字节）的简易数据库管理系统。实现如下功能：
- 实现数据库连接算法：nest-loop-join，sort-merge-join，hash-join算法。
- 实现搜索算法：线性搜索，⼆分搜索，聚簇索引搜索，b树索引搜索。
- 实现集合操作（交集/并集/查集）以及投影操作。

## 怎么做的？
### 物理存储结构
磁盘缓冲区结构, 大小默认520字节，磁盘块大小默认64字节，由此可知缓冲区的中最多能有8个磁盘块
```c++
typedef struct tagBuffer {
    unsigned long numIO; //io次数
    size_t bufSize; //缓冲区大小，520字节
    size_t blkSize; //磁盘块大小，64字节
    size_t numAllBlk; //缓冲区已有的磁盘块数目，最大
    size_t numFreeBlk; //缓冲区可用的磁盘块数目
    unsigned char *data; //缓冲区开始地址
} Buffer;
```
磁盘块以连接形式存储，磁盘块大小限制在64字节, 磁盘块的地址作为文件名来模拟。
```c++
typedef struct block{
    data int[15]; //60字节任意使用的区域
    unsigned int nblkaddr; //下一个块地址4字节
}block;
```
处理数据对象以元组或连接元组形式组织。元组包含两个属性值，均为int; 连接元组为两个元组连接的结果，包含3个属性值，均为int。
```c++
/*元祖结构体 8字节*/
typedef struct tuple
{
	int elem1; //属性A
	int elem2; //属性B
}tuple;
/*连接元祖12字节*/
typedef struct jtuple
{
	int elem1; //A
	int elem2; //B
    int elem3; //C
}jtuple;
```
### 磁盘操作
磁盘操作包括读/写/删除磁盘数据
#### 写一个磁盘块磁盘
1. 从缓冲区分配1个可用块
2. 把内容拷贝到缓冲区
3. 设置磁盘块的后继磁盘块地址
4. 将缓冲区内容写到磁盘
5. 释放缓冲区

#### 读一个磁盘块到内存
1. 读取指定磁盘块到缓冲区
2. 对缓冲区数据进行操作
3. 释放缓冲区

### 外部排序算法

#### 合并有序磁盘块链接（merger）
缓冲区分配：2个块用于第1个有序磁盘块链接；2个块用于第2个有序磁盘块链接；3个块用于输出缓冲区。中间的合并结果放在临时磁盘块起始地址。
算法基本步骤，假设要合并L和R两个有序磁盘块链接
1. 加载L和R的2个磁盘块到缓冲区；
2. while L和R均未读取完：
3.     将较小的值放入输出缓冲区;
4.     IF 输出缓冲区满了：将输出缓冲区写入磁盘；
5.     IF L缓冲区数据使用完毕且仍有后继块：读取至多2各块到缓冲区
6.     IF R缓冲区数据使用完毕且仍有后继块：读取至多2各块到缓冲区
7. IF L缓冲区中有剩余元素：将缓冲区数据写入磁盘
8. IF R缓冲区中有剩余元素：将缓冲区数据写入磁盘
9. 将L和R两个有序磁盘块链接在一起
10. 将中间临时结果内容拷贝到以L起始的磁盘链接。

#### 递归外部排序  
1. 计算中间磁盘块地址mid
2. 递归排序左半边
3. 递归排序右半边
4. 合并走右半边

#### 提高算法效率
1. 先将6个磁盘块的数据读取到缓冲区，进行内部排序（冒泡），然后写回到磁盘。
2. 然后再用外部归并排序。

### hash桶算法

#### 数据结构
```c++
/*hash节点*/
typedef struct hashnode{
    tuple item; //8字节
    struct hashnode *next; //8字节
}hashnode;
/*hash桶？*/
typedef struct hashbucket {
    int key; //键值，hash值取模
    int num; //桶内元素数目？
    int blknum; //块数目
    unsigned int first_addr; //起始地址
    unsigned int end_addr; //末尾地址
}hashbucket;
```
#### 创建hash桶
1. 初始化指定数目的hash桶
2. while 还有下个磁盘块：
3.     加载4个块到缓冲区；
4.     For 缓冲区的每个元素：
5.         计算元素的hash值
6.         根据hash值找到对应的hash桶
7.         计算在hash桶中的插入位置
8.         把插入位置所在块读取到缓冲区
9.         将元素插入到对应位置，并写回磁盘
10.        IF 插入位置是一个新的磁盘块
11.           将元素写入到新的磁盘块，并更新hash桶信息。

#### 

### 索引建立算法

#### 聚簇索引
数据已经安索引域排序了.
1. while 关系R未读取完:
2.     从磁盘读取关系R的4个磁盘块到缓冲区;
3.     找到key值第一个出现的元组,记录其地址到输出缓冲区
4.     如果输出缓冲区满了,写回磁盘

### 自然连接join算法

#### 循环嵌套连接(Nest-Loop-Join)算法
指定关系R和S的起始磁盘块地址，并分配缓冲区使用（R占5块，S占1块，输出缓冲区占1块）
实现基本步骤：
1. while 关系R未读取完 :
2.     从磁盘读取关系R的5个磁盘块到缓冲区X;
3.     while 关系S未读取完：
4.         从磁盘读取关系S的1个磁盘块到缓冲区Y；
5.         for X 和 Y 中的每个元素：
6.            IF x.A == y.B ：构造连接元组并写入缓冲区；
7.            IF 输出缓冲区满了：将输出缓冲区内容写入磁盘
#### 排序合并连接(Sort-Merge-Join)算法
指定关系R和S的起始磁盘块地址，并分配缓冲区使用（R占3块，S占3块，输出缓冲区占1块）
实现基本步骤：
1. 外部排序关系R
2. 外部排序关系S
3. while R和S 均未读取完
4.     维护双指针，分别指向R和S，将相同的写入输出缓冲区
5.     IF　输出缓冲区满了：写回磁盘
6.     IF  S缓冲区读完 且 有后继磁盘块：读取3块到缓冲区
7.     IF  R缓冲区读完 且 有后继磁盘块：读取3块到缓冲区
#### Hash-连接(Hash-Join)算法
指定桶大小16，并分配缓冲区使用（R占3块，S占3块，输出缓冲区占1块）
1. 创建关系R的hash桶
2. 创建关系S的hash桶
3. For 每个hash桶：
4.     while R和S 均未读取完
5.         维护双指针，分别指向R和S，将相同的构造连接元组写入输出缓冲区
6.         IF　输出缓冲区满了：写回磁盘
7.         IF  S缓冲区读完 且 有后继磁盘块：读取3块到缓冲区
8.         IF  R缓冲区读完 且 有后继磁盘块：读取3块到缓冲区

### 投影
分配缓冲区使用（R占4块，输出缓冲区占3块）
1. 排序关系R
2. While 关系R未读取完：
3.     读取R的4块到缓冲区
4.     去掉所有重复项，并写入输出缓冲区
5.     输出缓冲区满了写回磁盘
6.     R缓冲区读完了，重新从磁盘读取。

### 集合运算

#### 交集
指定关系R和S的起始磁盘块地址，并分配缓冲区使用（R占3块，S占3块，输出缓冲区占1块）
1. while R和S 均未读取完
2.     维护双指针，分别指向R和S，将相同的写入输出缓冲区
3.     IF　输出缓冲区满了：写回磁盘
4.     IF  S缓冲区读完 且 有后继磁盘块：读取3块到缓冲区
5.     IF  R缓冲区读完 且 有后继磁盘块：读取3块到缓冲区

#### 差集
类似nest-loop算法，把所有在R中但不在S中的元组找到
#### 并集
类似nest-loop算法，把所有在R中或在S中的元组找到，去除重复元素

### 查找算法

#### 线性搜索
指定关系R的起始地址，目标属性的值
1. while R未读取完:
2.     加载R的磁盘块到缓冲区
3.     线性扫描缓冲区
4.     将满足条件的元组写入输出缓冲区
5.     IF 输出缓冲区满了,写回磁盘

#### 二分搜索(针对有序的)
指定关系R的起始地址，目标属性的值
1. while R未读取完:
2.     加载R的磁盘块到缓冲区
3.     二分查找缓冲区(找到一个目标值)
4.     IF 如果找到目标属性值
5.        线性查找所有的目标值

#### 索引搜索
指定关系R的起始地址，目标属性的值
1. 排序关系R
2. 建立关系R的聚簇索引
3. while 索引文件为读取完:
4.     找到目标属性值,获取对应的地址
5. 从起始地址开始查找所有的相同元组

#### b树索引
##### b树结构
```c++
//8字节
typedef struct keynode{
    int elem;   //关键字
    unsigned int blkaddr;//存储关键字匹配的地址的磁盘块地址
}keynode;
//64字节
typedef struct BTNode{
    int keynum; //最大为6
    unsigned int parent;  // 指向双亲结点的磁盘块地址
    keynode key[7]; // 关键字向量，0号单元未用
    unsigned int childs[7];   // 子树指针磁盘块地址
}BTNode;
```